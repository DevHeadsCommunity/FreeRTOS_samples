/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

 //for print f
#include <stdint.h>
#include <stdio.h>

#include "../CMSIS/Inc/main.h"
#include "../CMSIS/Inc/stm32f407xx.h"
#include "../freertos/source/include/FreeRTOS.h"
#include "../freertos/source/include/task.h"

//RTOS Funcs 
// This function is called every tick interrupt.
void vApplicationTickHook(void)
{
    // Optional: Add your custom tick hook code here
	Timer_Update();
	printf("I am invoked \n");
}

// This function is called when a stack overflow is detected.
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName)
{
    // Optional: Add your custom stack overflow handling code here
    // For example, you can reset the system or enter an infinite loop
	printf("Stack overflow! \n");
    (void)xTask;
    (void)pcTaskName;
    for (;;);
}

void vApplicationMallocFailedHook(void) {
    // Handle malloc failure, e.g., log an error or reset the system
    // For now, an empty implementation will suffice
	printf("Malloc Failed \n");
    while (1);
}

void vApplicationIdleHook(void) {
    // Perform low-priority tasks or go to low-power mode
    // For now, an empty implementation will suffice
	printf("We are indle \n");
}





Lis3_Config_t Accel_1;
volatile uint8_t SHOULD_READ = 1;

static void ConfigureTim7(void);
void Sys_Init();

I2C_Handle_t I2C1Handle;
#define device_id 0xAA;









int main(void)
{	
	
	
	//Setup Systick so we remove delays
	Sys_Init();
	//Timer_Init();
	//ConfigureTim7();

	/*I2c*/
	uint32_t rcc_speed =   RCC_GetPCLK1Value();

	printf("System booted with Default clock of: %d MHz \n", rcc_speed);




	//Setup I2c
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN; 
	uint32_t altfn_reg;

	//get this pins altfn reg
	altfn_reg = 6%8;
	GPIOB->AFR[0] |= 4 << (altfn_reg * 4);
	//Set up pins
	GPIOB->MODER |= GPIO_MODER_MODER6_1;
	GPIOB->OTYPER |= GPIO_OTYPER_OT6;
	// Very fast speed for i2c
	GPIOB->OSPEEDR |= GPIO_OSPEEDER_OSPEEDR6;
	GPIOB->PUPDR |= GPIO_PUPDR_PUPDR6_0;
	
	
	//get this pins altfn reg
	altfn_reg = 7%8;
	GPIOB->AFR[0] |= 4 << (altfn_reg * 4);

	GPIOB->MODER |= GPIO_MODER_MODER7_1;
	GPIOB->OTYPER |= GPIO_OTYPER_OT7;
	GPIOB->OSPEEDR |= GPIO_OSPEEDER_OSPEEDR7;
	GPIOB->PUPDR |= GPIO_PUPDR_PUPDR7_0;
	

	printf("GPIO setup on port b pin 6 scl pin 7 sda \n");

	//Init i2c1
	I2C1Handle.pI2Cx = I2C1;
	I2C1Handle.I2C_Config.I2C_ACKControl = ASSERT;
	I2C1Handle.I2C_Config.I2C_DeviceAddress = device_id;
	I2C1Handle.I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2;
	I2C1Handle.I2C_Config.I2C_SCLSpeed = I2C_SCL_SPEED_SM;
	I2C_Init(&I2C1Handle);

	uint8_t code = 0x00;
	uint8_t addr = 0x68;
	uint8_t rx_buf[3];

	uint8_t rxes[2] = {0x00, 0x7F};
	// Send some data
	I2C_MasterSendData(&I2C1Handle, rxes, 2, addr, REFUTE);

	//for(uint32_t i = 0; i < 200000; i++){}
	
	//I2C_MasterReceiveData(&I2C1Handle, rx_buf, 3, addr, REFUTE);
	

	/*end i2c*/

	//start freertos
	//vTaskStartScheduler();

	
	
	

	//Blue LED CMSIS
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;
	GPIOD->MODER |= GPIO_MODER_MODER15_0;
	GPIOD->MODER &= ~GPIO_MODER_MODER15_1;
	GPIOD->OTYPER &= ~GPIO_OTYPER_OT_15;
	GPIOD->OSPEEDR |= GPIO_OSPEEDER_OSPEEDR15_0;
	GPIOD->OSPEEDR &= ~GPIO_OSPEEDER_OSPEEDR15_1;
	GPIOD->PUPDR &= ~GPIO_PUPDR_PUPDR15_0;
	GPIOD->PUPDR &= ~GPIO_PUPDR_PUPDR15_1;

	//Make a timer for main 
	DelayTimer_t mainTimer;
	Timer_Start(&mainTimer, 20);
	uint32_t myTimNum = numTimers++;
	timers[myTimNum] = &mainTimer;

	
	while(1) {
		float x_reading = Lis3ReadAxis('x');
		//printf("Combined X axis movement in mg: %.1f and  \n", x_reading);

		if(SHOULD_READ == 1){
			GPIOD->BSRR |= GPIO_BSRR_BS_15;
			

			while(!Timer_IsElapsed(&mainTimer)) {
				//we should yield to other tasks here ...	
				__WFI(); // Let's sleep we can be interrupted but will wait
			}
			
			int8_t today_temp = Lis3ReadTemp();
			printf("Temp is %dC Degrees Celsius \n", today_temp);
			
			GPIOD->BSRR |= GPIO_BSRR_BR_15;
			SHOULD_READ = 0;


			//AdcReadChannel(16);
		}
		
		
	}

	return 0;
}



void Sys_Init(){
	//enable FPU
	SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));

	


	/*LIS3 Setup*/
    //choose datarate, filter, axes
	Accel_1.Lis3_DR = 0x60;
	Accel_1.Lis3_BDU = 0x0;
	Accel_1.Lis3_Axes = 0x7;
	Accel_1.Lis3_Sensitivity = SENSITIVITY_2G;
	/* END LIS3 Setup*/

	/*ADC SETup*/

	AdcInit();

	/* End ADC SETUP */

	

	/*SPI Read Write*/
	uint8_t read_address = 0x0F;
	uint8_t read_data = 0xAA;
	uint8_t read_settings = 0xFF;
	uint8_t ctrl_4 = 0x20;
	
	Lis3_Init(Accel_1);
	
	Lis3WriteRead(read_address, &read_data);
	printf("ID Data: %#X \n", read_data);
	Lis3WriteRead(ctrl_4, &read_settings);
	printf("ODR and Axes Config Data: %#X \n", read_settings);
	/*End SPI Read Write*/
	

	
}


/*
 * Configure timer 3 so that we can use it for some delays
 */
static void ConfigureTim7(void){
	//enable clock for timer 7
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;

	// set a prescaler so we get 1KHz
	//Required freq = CLK / (PSC + 1)
	TIM7->PSC = 9999;

	/* So, this will generate the 1ms delay */
	TIM7->ARR = 47999;

	//Enable timer to generate update events
	TIM7->EGR |= TIM_EGR_UG;

	/* Enable the Interrupt */
	TIM7->DIER |= TIM_DIER_UIE;

	/* Clear the Interrupt Status */
	TIM7->SR &= ~TIM_SR_UIF;

	/* Enable NVIC Interrupt for Timer 6 */
	NVIC_EnableIRQ(TIM7_IRQn);
	

	/* Finally enable TIM3 module */
	TIM7->CR1 = (1 << 0);
}

void TIM7_IRQHandler(void) {
	//check if UIF flag is set
	if (TIM7->SR & TIM_SR_UIF) {
		// Clear Interrupt Flag
		TIM7->SR &= ~(TIM_SR_UIF);
	}
	SHOULD_READ = 1;
}

void I2C1_EV_IRQHandler (void)
{
	I2C_EV_IRQHandling(&I2C1Handle);
}


void I2C1_ER_IRQHandler (void)
{
	I2C_ER_IRQHandling(&I2C1Handle);
}

void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle,uint8_t AppEv)
{
     if(AppEv == I2C_EV_TX_CMPLT)
     {
    	 printf("i2c Tx is completed\n");
     }else if (AppEv == I2C_EV_RX_CMPLT)
     {
    	 printf("Rx is completed\n");
    	 //rxComplt = SET;
     }else if (AppEv == I2C_ERROR_AF)
     {
    	 printf("Error : Ack failure\n");
    	 //in master ack failure happens when slave fails to send ack for the byte
    	 //sent from the master.
    	 I2C_CloseSendData(pI2CHandle);

    	 //generate the stop condition to release the bus
    	 I2C_GenerateStopCondition(I2C1);

    	 //Hang in infinite loop
    	 //while(1);
     }
}

